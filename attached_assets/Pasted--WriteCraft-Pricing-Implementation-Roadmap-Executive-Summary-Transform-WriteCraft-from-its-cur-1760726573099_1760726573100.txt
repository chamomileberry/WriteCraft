# WriteCraft Pricing Implementation Roadmap

## Executive Summary

Transform WriteCraft from its current unlimited free access model into a sustainable freemium subscription SaaS with four tiers: Free Writer ($0), Author ($19/mo), Professional ($39/mo), and Team ($79/mo). This document provides a phased implementation plan with exact technical specifications.

---

## Phase 1: Foundation (Weeks 1-3)
**Goal**: Add subscription infrastructure without disrupting current users

### 1.1 Database Schema Extensions

**New Tables to Create:**

```sql
-- User Subscription Information
CREATE TABLE user_subscriptions (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tier VARCHAR NOT NULL CHECK (tier IN ('free', 'author', 'professional', 'team')),
  status VARCHAR NOT NULL CHECK (status IN ('active', 'past_due', 'canceled', 'trialing')),
  
  -- Stripe Integration
  stripe_customer_id VARCHAR UNIQUE,
  stripe_subscription_id VARCHAR UNIQUE,
  stripe_price_id VARCHAR,
  
  -- Billing Cycle
  current_period_start TIMESTAMP,
  current_period_end TIMESTAMP,
  cancel_at_period_end BOOLEAN DEFAULT false,
  
  -- Trial Management
  trial_start TIMESTAMP,
  trial_end TIMESTAMP,
  
  -- Timestamps
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  -- Ensure one active subscription per user
  UNIQUE(user_id) WHERE status = 'active'
);

-- AI Usage Tracking
CREATE TABLE ai_usage_logs (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Usage Details
  operation_type VARCHAR NOT NULL, -- 'character_gen', 'chat', 'edit', 'proofread', etc.
  model VARCHAR NOT NULL, -- 'claude-sonnet-4', 'claude-haiku-3-5'
  input_tokens INTEGER NOT NULL,
  output_tokens INTEGER NOT NULL,
  cached_tokens INTEGER DEFAULT 0,
  
  -- Cost Calculation (in cents)
  estimated_cost_cents INTEGER NOT NULL,
  
  -- Context
  project_id VARCHAR REFERENCES projects(id) ON DELETE SET NULL,
  notebook_id VARCHAR REFERENCES notebooks(id) ON DELETE SET NULL,
  
  -- Metadata
  created_at TIMESTAMP DEFAULT NOW(),
  
  -- Indexes for efficient querying
  INDEX idx_user_date (user_id, created_at),
  INDEX idx_user_operation (user_id, operation_type)
);

-- Daily Usage Summaries (for performance)
CREATE TABLE ai_usage_daily_summary (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  date DATE NOT NULL,
  
  -- Aggregated Counts
  total_operations INTEGER DEFAULT 0,
  total_input_tokens INTEGER DEFAULT 0,
  total_output_tokens INTEGER DEFAULT 0,
  total_cost_cents INTEGER DEFAULT 0,
  
  -- By Operation Type (JSONB for flexibility)
  operations_breakdown JSONB DEFAULT '{}',
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(user_id, date)
);

-- Team Management
CREATE TABLE team_memberships (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  team_subscription_id VARCHAR NOT NULL REFERENCES user_subscriptions(id) ON DELETE CASCADE,
  user_id VARCHAR NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role VARCHAR NOT NULL CHECK (role IN ('owner', 'admin', 'member')),
  
  -- Permissions
  can_edit BOOLEAN DEFAULT true,
  can_comment BOOLEAN DEFAULT true,
  can_invite BOOLEAN DEFAULT false,
  
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(team_subscription_id, user_id)
);

-- Lifetime Deal Tracking
CREATE TABLE lifetime_subscriptions (
  id VARCHAR PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id VARCHAR NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  
  -- Purchase Details
  purchase_date TIMESTAMP DEFAULT NOW(),
  purchase_price_cents INTEGER NOT NULL,
  tier_equivalent VARCHAR NOT NULL, -- 'professional'
  
  -- Usage Limits (for lifetime users)
  daily_generation_limit INTEGER DEFAULT 50,
  
  -- Status
  is_active BOOLEAN DEFAULT true,
  
  UNIQUE(user_id)
);
```

**Schema Migration File**: `db/migrations/001_add_subscription_tables.sql`

### 1.2 Update Users Table

```sql
-- Add subscription-related fields to existing users table
ALTER TABLE users ADD COLUMN subscription_tier VARCHAR DEFAULT 'free';
ALTER TABLE users ADD COLUMN grandfathered_tier VARCHAR; -- For price increases
ALTER TABLE users ADD COLUMN onboarding_completed BOOLEAN DEFAULT false;
ALTER TABLE users ADD COLUMN trial_used BOOLEAN DEFAULT false;
```

### 1.3 TypeScript Type Definitions

**File**: `shared/types/subscription.ts`

```typescript
export type SubscriptionTier = 'free' | 'author' | 'professional' | 'team';
export type SubscriptionStatus = 'active' | 'past_due' | 'canceled' | 'trialing';

export interface UserSubscription {
  id: string;
  userId: string;
  tier: SubscriptionTier;
  status: SubscriptionStatus;
  stripeCustomerId?: string;
  stripeSubscriptionId?: string;
  currentPeriodStart?: Date;
  currentPeriodEnd?: Date;
  cancelAtPeriodEnd: boolean;
  trialStart?: Date;
  trialEnd?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export interface TierLimits {
  name: string;
  price: number; // Monthly price in dollars
  annualPrice: number;
  maxProjects: number | null; // null = unlimited
  maxNotebooks: number | null;
  aiGenerationsPerDay: number | null;
  hasCollaboration: boolean;
  maxTeamMembers: number;
  hasApiAccess: boolean;
  hasPrioritySupport: boolean;
  exportFormats: string[]; // ['txt', 'docx', 'epub', 'pdf']
}

export const TIER_LIMITS: Record<SubscriptionTier, TierLimits> = {
  free: {
    name: 'Writer',
    price: 0,
    annualPrice: 0,
    maxProjects: 3,
    maxNotebooks: 1,
    aiGenerationsPerDay: 20,
    hasCollaboration: false,
    maxTeamMembers: 1,
    hasApiAccess: false,
    hasPrioritySupport: false,
    exportFormats: ['txt', 'docx']
  },
  author: {
    name: 'Author',
    price: 19,
    annualPrice: 180, // 21% discount
    maxProjects: null,
    maxNotebooks: null,
    aiGenerationsPerDay: 100,
    hasCollaboration: false,
    maxTeamMembers: 1,
    hasApiAccess: false,
    hasPrioritySupport: false,
    exportFormats: ['txt', 'docx', 'epub', 'pdf', 'markdown', 'fdx']
  },
  professional: {
    name: 'Professional',
    price: 39,
    annualPrice: 372, // 21% discount
    maxProjects: null,
    maxNotebooks: null,
    aiGenerationsPerDay: null, // Unlimited
    hasCollaboration: true,
    maxTeamMembers: 3,
    hasApiAccess: true,
    hasPrioritySupport: true,
    exportFormats: ['txt', 'docx', 'epub', 'pdf', 'markdown', 'fdx']
  },
  team: {
    name: 'Team',
    price: 79,
    annualPrice: 756, // 20% discount
    maxProjects: null,
    maxNotebooks: null,
    aiGenerationsPerDay: null,
    hasCollaboration: true,
    maxTeamMembers: 10,
    hasApiAccess: true,
    hasPrioritySupport: true,
    exportFormats: ['txt', 'docx', 'epub', 'pdf', 'markdown', 'fdx']
  }
};
```

### 1.4 Subscription Service Layer

**File**: `server/services/subscriptionService.ts`

```typescript
import { db } from '../db';
import { users, userSubscriptions, aiUsageLogs, aiUsageDailySummary } from '@shared/schema';
import { eq, and, sql, gte, lte } from 'drizzle-orm';
import { TIER_LIMITS, type SubscriptionTier } from '@shared/types/subscription';

export class SubscriptionService {
  /**
   * Get user's current subscription with tier limits
   */
  async getUserSubscription(userId: string) {
    const [subscription] = await db
      .select()
      .from(userSubscriptions)
      .where(eq(userSubscriptions.userId, userId))
      .limit(1);
    
    if (!subscription) {
      // Create default free subscription for existing users
      return this.createFreeSubscription(userId);
    }
    
    return {
      ...subscription,
      limits: TIER_LIMITS[subscription.tier]
    };
  }
  
  /**
   * Create free subscription for new/existing users
   */
  async createFreeSubscription(userId: string) {
    const [subscription] = await db
      .insert(userSubscriptions)
      .values({
        userId,
        tier: 'free',
        status: 'active'
      })
      .returning();
    
    return {
      ...subscription,
      limits: TIER_LIMITS.free
    };
  }
  
  /**
   * Check if user can perform action (respects tier limits)
   */
  async canPerformAction(userId: string, action: string): Promise<{ allowed: boolean; reason?: string }> {
    const subscription = await this.getUserSubscription(userId);
    
    switch (action) {
      case 'create_project':
        if (subscription.limits.maxProjects === null) return { allowed: true };
        const projectCount = await this.getUserProjectCount(userId);
        return {
          allowed: projectCount < subscription.limits.maxProjects,
          reason: projectCount >= subscription.limits.maxProjects 
            ? `You've reached your limit of ${subscription.limits.maxProjects} projects. Upgrade to create more.`
            : undefined
        };
      
      case 'ai_generation':
        if (subscription.limits.aiGenerationsPerDay === null) return { allowed: true };
        const todayUsage = await this.getTodayAIUsage(userId);
        return {
          allowed: todayUsage < subscription.limits.aiGenerationsPerDay,
          reason: todayUsage >= subscription.limits.aiGenerationsPerDay
            ? `You've reached your daily limit of ${subscription.limits.aiGenerationsPerDay} AI generations. Upgrade for more.`
            : undefined
        };
      
      default:
        return { allowed: true };
    }
  }
  
  /**
   * Log AI usage for tracking and billing
   */
  async logAIUsage(params: {
    userId: string;
    operationType: string;
    model: string;
    inputTokens: number;
    outputTokens: number;
    cachedTokens?: number;
    projectId?: string;
    notebookId?: string;
  }) {
    // Calculate cost in cents
    const costCents = this.calculateCostCents(
      params.model,
      params.inputTokens,
      params.outputTokens,
      params.cachedTokens
    );
    
    // Log detailed usage
    await db.insert(aiUsageLogs).values({
      userId: params.userId,
      operationType: params.operationType,
      model: params.model,
      inputTokens: params.inputTokens,
      outputTokens: params.outputTokens,
      cachedTokens: params.cachedTokens || 0,
      estimatedCostCents: costCents,
      projectId: params.projectId,
      notebookId: params.notebookId
    });
    
    // Update daily summary
    await this.updateDailySummary(params.userId, {
      operations: 1,
      inputTokens: params.inputTokens,
      outputTokens: params.outputTokens,
      costCents
    });
  }
  
  /**
   * Get today's AI generation count
   */
  private async getTodayAIUsage(userId: string): Promise<number> {
    const today = new Date().toISOString().split('T')[0];
    const [summary] = await db
      .select()
      .from(aiUsageDailySummary)
      .where(
        and(
          eq(aiUsageDailySummary.userId, userId),
          eq(aiUsageDailySummary.date, sql`${today}::date`)
        )
      );
    
    return summary?.totalOperations || 0;
  }
  
  /**
   * Calculate cost in cents based on model and tokens
   */
  private calculateCostCents(
    model: string,
    inputTokens: number,
    outputTokens: number,
    cachedTokens: number = 0
  ): number {
    // Claude Sonnet 4 pricing: $3 input, $15 output per 1M tokens
    // Claude Haiku pricing: $0.25 input, $1.25 output per 1M tokens
    // Cached tokens: 90% discount
    
    const pricing = model.includes('haiku') 
      ? { input: 0.25, output: 1.25, cache: 0.025 }
      : { input: 3, output: 15, cache: 0.3 };
    
    const inputCost = (inputTokens / 1_000_000) * pricing.input * 100;
    const outputCost = (outputTokens / 1_000_000) * pricing.output * 100;
    const cacheCost = (cachedTokens / 1_000_000) * pricing.cache * 100;
    
    return Math.ceil(inputCost + outputCost + cacheCost);
  }
  
  /**
   * Get user's project count
   */
  private async getUserProjectCount(userId: string): Promise<number> {
    const result = await db
      .select({ count: sql<number>`count(*)` })
      .from(projects)
      .where(eq(projects.userId, userId));
    
    return result[0]?.count || 0;
  }
  
  /**
   * Update daily summary statistics
   */
  private async updateDailySummary(
    userId: string, 
    delta: { operations: number; inputTokens: number; outputTokens: number; costCents: number }
  ) {
    const today = new Date().toISOString().split('T')[0];
    
    await db
      .insert(aiUsageDailySummary)
      .values({
        userId,
        date: sql`${today}::date`,
        totalOperations: delta.operations,
        totalInputTokens: delta.inputTokens,
        totalOutputTokens: delta.outputTokens,
        totalCostCents: delta.costCents
      })
      .onConflictDoUpdate({
        target: [aiUsageDailySummary.userId, aiUsageDailySummary.date],
        set: {
          totalOperations: sql`${aiUsageDailySummary.totalOperations} + ${delta.operations}`,
          totalInputTokens: sql`${aiUsageDailySummary.totalInputTokens} + ${delta.inputTokens}`,
          totalOutputTokens: sql`${aiUsageDailySummary.totalOutputTokens} + ${delta.outputTokens}`,
          totalCostCents: sql`${aiUsageDailySummary.totalCostCents} + ${delta.costCents}`,
          updatedAt: sql`NOW()`
        }
      });
  }
}

export const subscriptionService = new SubscriptionService();
```

---

## Phase 2: AI Usage Tracking & Limits (Weeks 3-4)
**Goal**: Track all AI operations and enforce tier limits

### 2.1 Wrap All AI Generation Functions

**File**: `server/middleware/aiUsageMiddleware.ts`

```typescript
import { subscriptionService } from '../services/subscriptionService';

export async function trackAIUsage(
  handler: (params: any) => Promise<any>,
  operationType: string
) {
  return async (req: any, res: any, next: any) => {
    const userId = req.user?.claims?.sub;
    
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    // Check if user can perform AI generation
    const permission = await subscriptionService.canPerformAction(userId, 'ai_generation');
    
    if (!permission.allowed) {
      return res.status(403).json({
        error: 'Usage limit exceeded',
        message: permission.reason,
        upgradeUrl: '/pricing'
      });
    }
    
    // Execute the handler and track usage
    try {
      const result = await handler(req, res, next);
      
      // Extract token usage from Anthropic response
      // This requires modifying ai-generation.ts to return usage metadata
      if (result.usage) {
        await subscriptionService.logAIUsage({
          userId,
          operationType,
          model: result.model || 'claude-sonnet-4',
          inputTokens: result.usage.input_tokens,
          outputTokens: result.usage.output_tokens,
          cachedTokens: result.usage.cache_read_input_tokens,
          projectId: req.body.projectId,
          notebookId: req.body.notebookId
        });
      }
      
      return result;
    } catch (error) {
      console.error(`AI generation error for ${operationType}:`, error);
      throw error;
    }
  };
}
```

### 2.2 Modify All AI Generation Functions

**Update**: `server/ai-generation.ts`

Add usage tracking to EVERY AI function:

```typescript
// Example for generateCharacter
export async function generateCharacter(
  options: CharacterGenerationOptions,
  userId: string,
  notebookId?: string
): Promise<{ character: GeneratedCharacter; usage: any }> {
  // ... existing code ...
  
  const response = await anthropic.messages.create({
    model: DEFAULT_MODEL_STR,
    system: systemPrompt,
    max_tokens: 3500,
    messages: [{ role: 'user', content: prompt }],
  });
  
  // ... existing processing ...
  
  // IMPORTANT: Return usage metadata
  return {
    character: validatedCharacter,
    usage: response.usage // Anthropic returns input_tokens, output_tokens, cache_read_input_tokens
  };
}
```

Apply this pattern to:
- `generateCharacter`
- `conversationalChat`
- `improveText`
- `proofreadText`
- `generateSynonyms`
- `generateQuestions`
- All other AI functions

### 2.3 Add Usage Dashboard Endpoint

**File**: `server/routes/usage.routes.ts`

```typescript
import { Router } from 'express';
import { subscriptionService } from '../services/subscriptionService';
import { db } from '../db';
import { aiUsageDailySummary } from '@shared/schema';
import { eq, gte, sql } from 'drizzle-orm';

const router = Router();

// Get current usage for today
router.get('/usage/today', async (req: any, res) => {
  const userId = req.user.claims.sub;
  const subscription = await subscriptionService.getUserSubscription(userId);
  
  const today = new Date().toISOString().split('T')[0];
  const [summary] = await db
    .select()
    .from(aiUsageDailySummary)
    .where(
      and(
        eq(aiUsageDailySummary.userId, userId),
        eq(aiUsageDailySummary.date, sql`${today}::date`)
      )
    );
  
  res.json({
    tier: subscription.tier,
    limits: subscription.limits,
    usage: {
      today: summary?.totalOperations || 0,
      remaining: subscription.limits.aiGenerationsPerDay 
        ? Math.max(0, subscription.limits.aiGenerationsPerDay - (summary?.totalOperations || 0))
        : null // null = unlimited
    }
  });
});

// Get usage history (last 30 days)
router.get('/usage/history', async (req: any, res) => {
  const userId = req.user.claims.sub;
  const thirtyDaysAgo = new Date();
  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
  
  const history = await db
    .select()
    .from(aiUsageDailySummary)
    .where(
      and(
        eq(aiUsageDailySummary.userId, userId),
        gte(aiUsageDailySummary.date, thirtyDaysAgo)
      )
    )
    .orderBy(aiUsageDailySummary.date);
  
  res.json({ history });
});

export default router;
```

---

## Phase 3: Stripe Integration (Weeks 4-6)
**Goal**: Enable subscription payments and management

### 3.1 Install Stripe Dependencies

```bash
npm install stripe @stripe/stripe-js
```

### 3.2 Environment Variables

Add to `.env`:
```
STRIPE_SECRET_KEY=sk_test_...
STRIPE_PUBLISHABLE_KEY=pk_test_...
STRIPE_WEBHOOK_SECRET=whsec_...
STRIPE_PRICE_ID_AUTHOR_MONTHLY=price_...
STRIPE_PRICE_ID_AUTHOR_ANNUAL=price_...
STRIPE_PRICE_ID_PRO_MONTHLY=price_...
STRIPE_PRICE_ID_PRO_ANNUAL=price_...
STRIPE_PRICE_ID_TEAM_MONTHLY=price_...
STRIPE_PRICE_ID_TEAM_ANNUAL=price_...
```

### 3.3 Stripe Service

**File**: `server/services/stripeService.ts`

```typescript
import Stripe from 'stripe';
import { db } from '../db';
import { userSubscriptions } from '@shared/schema';
import { eq } from 'drizzle-orm';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-11-20.acacia'
});

export class StripeService {
  /**
   * Create Stripe checkout session
   */
  async createCheckoutSession(params: {
    userId: string;
    email: string;
    priceId: string;
    tier: string;
  }) {
    const session = await stripe.checkout.sessions.create({
      mode: 'subscription',
      customer_email: params.email,
      line_items: [{
        price: params.priceId,
        quantity: 1
      }],
      success_url: `${process.env.BASE_URL}/subscription/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.BASE_URL}/pricing`,
      metadata: {
        userId: params.userId,
        tier: params.tier
      },
      subscription_data: {
        trial_period_days: 14,
        metadata: {
          userId: params.userId,
          tier: params.tier
        }
      }
    });
    
    return session;
  }
  
  /**
   * Create customer portal session
   */
  async createPortalSession(customerId: string) {
    const session = await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: `${process.env.BASE_URL}/settings/billing`
    });
    
    return session;
  }
  
  /**
   * Handle webhook events
   */
  async handleWebhook(event: Stripe.Event) {
    switch (event.type) {
      case 'checkout.session.completed':
        await this.handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
        break;
      
      case 'customer.subscription.updated':
        await this.handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
        break;
      
      case 'customer.subscription.deleted':
        await this.handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
        break;
      
      case 'invoice.payment_failed':
        await this.handlePaymentFailed(event.data.object as Stripe.Invoice);
        break;
    }
  }
  
  private async handleCheckoutCompleted(session: Stripe.Checkout.Session) {
    const userId = session.metadata!.userId;
    const tier = session.metadata!.tier as any;
    
    // Get subscription details
    const subscription = await stripe.subscriptions.retrieve(session.subscription as string);
    
    // Create or update user subscription
    await db
      .insert(userSubscriptions)
      .values({
        userId,
        tier,
        status: subscription.status === 'trialing' ? 'trialing' : 'active',
        stripeCustomerId: session.customer as string,
        stripeSubscriptionId: subscription.id,
        stripePriceId: subscription.items.data[0].price.id,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        trialStart: subscription.trial_start ? new Date(subscription.trial_start * 1000) : null,
        trialEnd: subscription.trial_end ? new Date(subscription.trial_end * 1000) : null
      })
      .onConflictDoUpdate({
        target: userSubscriptions.userId,
        set: {
          tier,
          status: subscription.status === 'trialing' ? 'trialing' : 'active',
          stripeSubscriptionId: subscription.id,
          stripePriceId: subscription.items.data[0].price.id,
          currentPeriodStart: new Date(subscription.current_period_start * 1000),
          currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          updatedAt: new Date()
        }
      });
  }
  
  private async handleSubscriptionUpdated(subscription: Stripe.Subscription) {
    const userId = subscription.metadata.userId;
    
    await db
      .update(userSubscriptions)
      .set({
        status: subscription.status as any,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        cancelAtPeriodEnd: subscription.cancel_at_period_end,
        updatedAt: new Date()
      })
      .where(eq(userSubscriptions.userId, userId));
  }
  
  private async handleSubscriptionDeleted(subscription: Stripe.Subscription) {
    const userId = subscription.metadata.userId;
    
    // Downgrade to free
    await db
      .update(userSubscriptions)
      .set({
        tier: 'free',
        status: 'canceled',
        updatedAt: new Date()
      })
      .where(eq(userSubscriptions.userId, userId));
  }
  
  private async handlePaymentFailed(invoice: Stripe.Invoice) {
    const customerId = invoice.customer as string;
    
    const [subscription] = await db
      .select()
      .from(userSubscriptions)
      .where(eq(userSubscriptions.stripeCustomerId, customerId));
    
    if (subscription) {
      await db
        .update(userSubscriptions)
        .set({
          status: 'past_due',
          updatedAt: new Date()
        })
        .where(eq(userSubscriptions.id, subscription.id));
    }
  }
}

export const stripeService = new StripeService();
```

### 3.4 Stripe Routes

**File**: `server/routes/stripe.routes.ts`

```typescript
import { Router } from 'express';
import { stripeService } from '../services/stripeService';
import { subscriptionService } from '../services/subscriptionService';
import express from 'express';

const router = Router();

// Create checkout session
router.post('/stripe/create-checkout', async (req: any, res) => {
  try {
    const userId = req.user.claims.sub;
    const { priceId, tier } = req.body;
    
    const session = await stripeService.createCheckoutSession({
      userId,
      email: req.user.claims.email,
      priceId,
      tier
    });
    
    res.json({ url: session.url });
  } catch (error) {
    console.error('Checkout error:', error);
    res.status(500).json({ error: 'Failed to create checkout session' });
  }
});

// Create portal session
router.post('/stripe/create-portal', async (req: any, res) => {
  try {
    const userId = req.user.claims.sub;
    const subscription = await subscriptionService.getUserSubscription(userId);
    
    if (!subscription.stripeCustomerId) {
      return res.status(400).json({ error: 'No active subscription' });
    }
    
    const session = await stripeService.createPortalSession(subscription.stripeCustomerId);
    res.json({ url: session.url });
  } catch (error) {
    console.error('Portal error:', error);
    res.status(500).json({ error: 'Failed to create portal session' });
  }
});

// Stripe webhook handler
router.post(
  '/stripe/webhook',
  express.raw({ type: 'application/json' }),
  async (req, res) => {
    const sig = req.headers['stripe-signature']!;
    
    try {
      const event = stripe.webhooks.constructEvent(
        req.body,
        sig,
        process.env.STRIPE_WEBHOOK_SECRET!
      );
      
      await stripeService.handleWebhook(event);
      res.json({ received: true });
    } catch (error) {
      console.error('Webhook error:', error);
      res.status(400).send(`Webhook Error: ${error.message}`);
    }
  }
);

export default router;
```

---

## Phase 4: Frontend Implementation (Weeks 6-8)
**Goal**: Build pricing page, upgrade flows, and usage indicators

### 4.1 Pricing Page Component

**File**: `client/src/pages/PricingPage.tsx`

```typescript
import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Check, Zap } from 'lucide-react';
import { useAuth } from '@/hooks/useAuth';
import { apiRequest } from '@/lib/queryClient';
import { TIER_LIMITS } from '@shared/types/subscription';

export function PricingPage() {
  const { user } = useAuth();
  const [billingCycle, setBillingCycle] = useState<'monthly' | 'annual'>('annual');
  const [loading, setLoading] = useState<string | null>(null);
  
  const tiers = [
    {
      id: 'author',
      name: 'Author',
      description: 'For aspiring authors and serious hobbyists',
      monthlyPrice: 19,
      annualPrice: 180,
      priceIds: {
        monthly: process.env.STRIPE_PRICE_ID_AUTHOR_MONTHLY,
        annual: process.env.STRIPE_PRICE_ID_AUTHOR_ANNUAL
      },
      features: [
        'Unlimited projects',
        '100 AI generations/day',
        'All 40+ worldbuilding tools',
        'Timeline & family trees',
        'Export: DOCX, PDF, ePub, Markdown',
        'Email support (48hr)'
      ]
    },
    {
      id: 'professional',
      name: 'Professional',
      description: 'For professional writers and content creators',
      monthlyPrice: 39,
      annualPrice: 372,
      priceIds: {
        monthly: process.env.STRIPE_PRICE_ID_PRO_MONTHLY,
        annual: process.env.STRIPE_PRICE_ID_PRO_ANNUAL
      },
      popular: true,
      features: [
        'Everything in Author',
        'Unlimited AI generations',
        'Collaboration (3 members)',
        'API access (5,000 calls/mo)',
        'Priority support (24hr)',
        'Multiple AI models'
      ]
    },
    {
      id: 'team',
      name: 'Team',
      description: 'For studios and collaborative teams',
      monthlyPrice: 79,
      annualPrice: 756,
      priceIds: {
        monthly: process.env.STRIPE_PRICE_ID_TEAM_MONTHLY,
        annual: process.env.STRIPE_PRICE_ID_TEAM_ANNUAL
      },
      features: [
        'Everything in Professional',
        'Up to 10 team members',
        'Role-based permissions',
        'Custom AI fine-tuning',
        'White-label exports',
        'Dedicated account manager'
      ]
    }
  ];
  
  const handleSubscribe = async (tierId: string, priceId: string) => {
    setLoading(tierId);
    
    try {
      const response = await apiRequest('POST', '/api/stripe/create-checkout', {
        priceId,
        tier: tierId
      });
      
      const { url } = await response.json();
      window.location.href = url;
    } catch (error) {
      console.error('Checkout error:', error);
      setLoading(null);
    }
  };
  
  return (
    <div className="max-w-7xl mx-auto px-4 py-16">
      <div className="text-center mb-12">
        <h1 className="text-4xl font-bold mb-4">Choose Your Plan</h1>
        <p className="text-xl text-muted-foreground mb-8">
          Start with 14 days free. No credit card required.
        </p>
        
        {/* Billing cycle toggle */}
        <div className="inline-flex items-center gap-4 bg-muted p-1 rounded-lg">
          <button
            onClick={() => setBillingCycle('monthly')}
            className={`px-4 py-2 rounded-md transition ${
              billingCycle === 'monthly' ? 'bg-background shadow' : ''
            }`}
          >
            Monthly
          </button>
          <button
            onClick={() => setBillingCycle('annual')}
            className={`px-4 py-2 rounded-md transition ${
              billingCycle === 'annual' ? 'bg-background shadow' : ''
            }`}
          >
            Annual <span className="text-green-600 ml-1">(Save 20%)</span>
          </button>
        </div>
      </div>
      
      {/* Free tier */}
      <div className="grid md:grid-cols-4 gap-6 mb-8">
        <Card className="p-6">
          <h3 className="text-xl font-bold mb-2">Writer</h3>
          <p className="text-muted-foreground mb-4">Get started for free</p>
          <div className="text-3xl font-bold mb-6">$0</div>
          <Button className="w-full mb-6" variant="outline">
            Current Plan
          </Button>
          <ul className="space-y-3 text-sm">
            <li className="flex items-start gap-2">
              <Check className="w-4 h-4 mt-0.5" />
              <span>3 projects</span>
            </li>
            <li className="flex items-start gap-2">
              <Check className="w-4 h-4 mt-0.5" />
              <span>20 AI generations/day</span>
            </li>
            <li className="flex items-start gap-2">
              <Check className="w-4 h-4 mt-0.5" />
              <span>Basic worldbuilding tools</span>
            </li>
          </ul>
        </Card>
        
        {/* Paid tiers */}
        {tiers.map(tier => (
          <Card 
            key={tier.id}
            className={`p-6 relative ${tier.popular ? 'border-primary border-2' : ''}`}
          >
            {tier.popular && (
              <div className="absolute -top-3 left-1/2 -translate-x-1/2 bg-primary text-primary-foreground px-3 py-1 rounded-full text-sm">
                Most Popular
              </div>
            )}
            
            <h3 className="text-xl font-bold mb-2">{tier.name}</h3>
            <p className="text-muted-foreground text-sm mb-4">{tier.description}</p>
            
            <div className="mb-6">
              <div className="text-3xl font-bold">
                ${billingCycle === 'monthly' ? tier.monthlyPrice : Math.floor(tier.annualPrice / 12)}
                <span className="text-lg font-normal text-muted-foreground">/mo</span>
              </div>
              {billingCycle === 'annual' && (
                <div className="text-sm text-muted-foreground">
                  ${tier.annualPrice} billed annually
                </div>
              )}
            </div>
            
            <Button
              className="w-full mb-6"
              onClick={() => handleSubscribe(tier.id, tier.priceIds[billingCycle])}
              disabled={loading === tier.id}
            >
              {loading === tier.id ? 'Loading...' : 'Start 14-day trial'}
            </Button>
            
            <ul className="space-y-3 text-sm">
              {tier.features.map(feature => (
                <li key={feature} className="flex items-start gap-2">
                  <Check className="w-4 h-4 mt-0.5 text-primary" />
                  <span>{feature}</span>
                </li>
              ))}
            </ul>
          </Card>
        ))}
      </div>
      
      {/* FAQ Section */}
      <div className="mt-16">
        <h2 className="text-2xl font-bold text-center mb-8">Frequently Asked Questions</h2>
        <div className="grid md:grid-cols-2 gap-6 max-w-4xl mx-auto">
          <div>
            <h3 className="font-semibold mb-2">Why subscription pricing?</h3>
            <p className="text-sm text-muted-foreground">
              AI models literally cost us money every time you use them. Subscriptions 
              keep AI unlimited instead of charging per use, plus fund continuous platform 
              improvements and new features.
            </p>
          </div>
          <div>
            <h3 className="font-semibold mb-2">Can I cancel anytime?</h3>
            <p className="text-sm text-muted-foreground">
              Yes! Cancel anytime and you'll keep access until your billing period ends. 
              No questions asked.
            </p>
          </div>
          <div>
            <h3 className="font-semibold mb-2">What happens after the trial?</h3>
            <p className="text-sm text-muted-foreground">
              You get 14 days of full access. If you don't upgrade, you'll automatically 
              switch to the Free tier and keep all your data.
            </p>
          </div>
          <div>
            <h3 className="font-semibold mb-2">Do you offer student discounts?</h3>
            <p className="text-sm text-muted-foreground">
              Yes! Students get 20% off with a valid .edu email. Contact support after 
              signing up.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 4.2 Usage Indicator Component

**File**: `client/src/components/UsageIndicator.tsx`

```typescript
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { Progress } from '@/components/ui/progress';
import { Button } from '@/components/ui/button';
import { Zap, TrendingUp } from 'lucide-react';

export function UsageIndicator() {
  const { data: usage } = useQuery({
    queryKey: ['usage', 'today'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/usage/today');
      return res.json();
    },
    refetchInterval: 60000 // Refresh every minute
  });
  
  if (!usage) return null;
  
  // If unlimited, don't show indicator
  if (usage.limits.aiGenerationsPerDay === null) {
    return (
      <div className="flex items-center gap-2 text-sm text-muted-foreground">
        <Zap className="w-4 h-4 text-primary" />
        <span>Unlimited AI</span>
      </div>
    );
  }
  
  const percentUsed = (usage.usage.today / usage.limits.aiGenerationsPerDay) * 100;
  const isNearLimit = percentUsed >= 80;
  
  return (
    <div className="space-y-2">
      <div className="flex items-center justify-between text-sm">
        <div className="flex items-center gap-2">
          <Zap className={`w-4 h-4 ${isNearLimit ? 'text-orange-500' : 'text-primary'}`} />
          <span>AI Generations Today</span>
        </div>
        <span className="font-medium">
          {usage.usage.today} / {usage.limits.aiGenerationsPerDay}
        </span>
      </div>
      
      <Progress 
        value={percentUsed} 
        className={isNearLimit ? 'bg-orange-100' : ''}
      />
      
      {isNearLimit && (
        <div className="flex items-center justify-between">
          <p className="text-xs text-muted-foreground">
            Running low on generations
          </p>
          <Button size="sm" variant="outline" asChild>
            <a href="/pricing">
              <TrendingUp className="w-3 h-3 mr-1" />
              Upgrade
            </a>
          </Button>
        </div>
      )}
    </div>
  );
}
```

### 4.3 Upgrade Prompt Component

**File**: `client/src/components/UpgradePrompt.tsx`

```typescript
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Crown } from 'lucide-react';

interface UpgradePromptProps {
  open: boolean;
  onClose: () => void;
  reason: string;
  feature: string;
}

export function UpgradePrompt({ open, onClose, reason, feature }: UpgradePromptProps) {
  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <div className="flex items-center gap-2 mb-2">
            <Crown className="w-6 h-6 text-primary" />
            <DialogTitle>Upgrade to Continue</DialogTitle>
          </div>
        </DialogHeader>
        
        <div className="space-y-4">
          <p className="text-muted-foreground">{reason}</p>
          
          <div className="bg-muted p-4 rounded-lg">
            <h4 className="font-semibold mb-2">With Professional Plan:</h4>
            <ul className="space-y-1 text-sm">
              <li>✓ Unlimited AI generations</li>
              <li>✓ Collaboration features</li>
              <li>✓ Priority support</li>
              <li>✓ All export formats</li>
            </ul>
          </div>
          
          <div className="flex gap-3">
            <Button className="flex-1" asChild>
              <a href="/pricing">View Plans</a>
            </Button>
            <Button variant="outline" onClick={onClose}>
              Maybe Later
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

---

## Phase 5: Feature Gating & Enforcement (Week 8-9)
**Goal**: Enforce limits across the entire application

### 5.1 Create Middleware for Feature Checks

**File**: `server/middleware/featureGate.ts`

```typescript
import { subscriptionService } from '../services/subscriptionService';

export function requireFeature(feature: string) {
  return async (req: any, res: any, next: any) => {
    const userId = req.user?.claims?.sub;
    
    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }
    
    const permission = await subscriptionService.canPerformAction(userId, feature);
    
    if (!permission.allowed) {
      return res.status(403).json({
        error: 'Feature not available',
        message: permission.reason,
        feature,
        upgradeUrl: '/pricing'
      });
    }
    
    next();
  };
}
```

### 5.2 Apply Feature Gates to Routes

**Update**: `server/routes/project.routes.ts`

```typescript
import { requireFeature } from '../middleware/featureGate';

// Create project - check project limit
router.post(
  '/projects',
  secureAuthentication,
  requireFeature('create_project'), // NEW: Check if user can create project
  async (req: any, res) => {
    // ... existing code
  }
);
```

**Update**: All AI generation routes in `server/routes/generate.routes.ts`

```typescript
import { requireFeature } from '../middleware/featureGate';

// Character generation
router.post(
  '/generate/character',
  secureAuthentication,
  requireFeature('ai_generation'), // NEW: Check AI generation limit
  async (req: any, res) => {
    // ... existing code with usage tracking
  }
);
```

### 5.3 Client-Side Feature Checking

**File**: `client/src/hooks/useSubscription.ts`

```typescript
import { useQuery } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';

export function useSubscription() {
  const { data: subscription, isLoading } = useQuery({
    queryKey: ['subscription'],
    queryFn: async () => {
      const res = await apiRequest('GET', '/api/subscription');
      return res.json();
    },
    staleTime: 5 * 60 * 1000 // Cache for 5 minutes
  });
  
  const canUseFeature = (feature: string) => {
    if (!subscription) return false;
    
    switch (feature) {
      case 'unlimited_ai':
        return subscription.limits.aiGenerationsPerDay === null;
      case 'collaboration':
        return subscription.limits.hasCollaboration;
      case 'api_access':
        return subscription.limits.hasApiAccess;
      case 'priority_support':
        return subscription.limits.hasPrioritySupport;
      default:
        return true;
    }
  };
  
  return {
    subscription,
    isLoading,
    canUseFeature,
    tier: subscription?.tier || 'free',
    limits: subscription?.limits
  };
}
```

---

## Phase 6: AI Cost Optimization (Week 9-10)
**Goal**: Implement prompt caching and model selection

### 6.1 Prompt Caching Implementation

**Update**: `server/ai-generation.ts`

Add caching to all major AI functions:

```typescript
import { createHash } from 'crypto';

// Cache manager for prompt prefixes
class PromptCacheManager {
  private cache = new Map<string, { prompt: string; timestamp: number }>();
  private TTL = 5 * 60 * 1000; // 5 minutes
  
  getCachedPrompt(userId: string, type: string): string | null {
    const key = `${userId}:${type}`;
    const cached = this.cache.get(key);
    
    if (!cached) return null;
    
    // Check if expired
    if (Date.now() - cached.timestamp > this.TTL) {
      this.cache.delete(key);
      return null;
    }
    
    return cached.prompt;
  }
  
  setCachedPrompt(userId: string, type: string, prompt: string) {
    const key = `${userId}:${type}`;
    this.cache.set(key, { prompt, timestamp: Date.now() });
  }
}

const promptCache = new PromptCacheManager();

// Example: Modified conversationalChat with caching
export async function conversationalChat(
  message: string,
  conversationHistory: Array<{ role: 'user' | 'assistant'; content: string }>,
  userId: string,
  editorContent?: string,
  projectId?: string
): Promise<{ response: string; usage: any }> {
  // Build cacheable context (user's world details, character profiles, etc.)
  let systemPrompt = baseSystemPrompt;
  
  // Get or create cached world context
  const cachedWorldContext = promptCache.getCachedPrompt(userId, 'world_context');
  if (cachedWorldContext) {
    systemPrompt += cachedWorldContext;
  } else if (projectId) {
    // Load world context from database
    const worldContext = await loadUserWorldContext(userId, projectId);
    systemPrompt += worldContext;
    promptCache.setCachedPrompt(userId, 'world_context', worldContext);
  }
  
  const response = await anthropic.messages.create({
    model: DEFAULT_MODEL_STR,
    system: [
      {
        type: 'text',
        text: systemPrompt,
        cache_control: { type: 'ephemeral' } // Cache this system prompt
      }
    ],
    max_tokens: 1024,
    messages: conversationHistory.concat([{ role: 'user', content: message }])
  });
  
  return {
    response: response.content[0].text,
    usage: response.usage
  };
}
```

### 6.2 Intelligent Model Selection

**File**: `server/services/modelSelector.ts`

```typescript
export class ModelSelector {
  /**
   * Select appropriate model based on task complexity
   */
  selectModel(operationType: string, textLength: number = 0): string {
    // Simple tasks -> Use Haiku (90% cheaper)
    const simpleOperations = [
      'name_generation',
      'synonym_generation',
      'word_definition',
      'title_generation',
      'tag_generation'
    ];
    
    if (simpleOperations.includes(operationType)) {
      return 'claude-3-5-haiku-20241022';
    }
    
    // Short text editing -> Use Haiku
    if (operationType === 'improve_text' && textLength < 500) {
      return 'claude-3-5-haiku-20241022';
    }
    
    // Complex tasks -> Use Sonnet
    return 'claude-sonnet-4-20250514';
  }
}

export const modelSelector = new ModelSelector();
```

**Update**: All AI generation functions to use model selector

```typescript
const model = modelSelector.selectModel(operationType, text.length);

const response = await anthropic.messages.create({
  model, // Use selected model
  // ...
});
```

---

## Phase 7: Migration & Rollout (Week 10-11)
**Goal**: Migrate existing users without disruption

### 7.1 Existing User Migration Script

**File**: `server/scripts/migrateExistingUsers.ts`

```typescript
import { db } from '../db';
import { users, userSubscriptions } from '@shared/schema';
import { subscriptionService } from '../services/subscriptionService';

async function migrateExistingUsers() {
  console.log('Starting user migration...');
  
  // Get all users without subscriptions
  const existingUsers = await db.select().from(users);
  
  for (const user of existingUsers) {
    try {
      // Check if user already has subscription
      const existing = await subscriptionService.getUserSubscription(user.id);
      if (existing.tier !== 'free') continue;
      
      // Grandfather existing users to Professional tier for 90 days
      // This shows goodwill and gives them time to evaluate
      await db.insert(userSubscriptions).values({
        userId: user.id,
        tier: 'professional',
        status: 'active',
        currentPeriodStart: new Date(),
        currentPeriodEnd: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
        grandfathered: true
      });
      
      console.log(`Migrated user ${user.id} with 90-day Professional access`);
    } catch (error) {
      console.error(`Error migrating user ${user.id}:`, error);
    }
  }
  
  console.log('Migration complete!');
}

migrateExistingUsers();
```

### 7.2 Announcement Email Template

**Subject**: "Introducing WriteCraft Premium - You're Grandfathered In!"

```
Hi [Name],

Big news! After months of development, we're launching WriteCraft Premium with professional AI features and collaboration tools.

Here's the best part: as an early supporter, you're grandfathered into the Professional plan ($39/month value) FREE for the next 90 days.

What you get with Professional:
✓ Unlimited AI generations (you're currently limited to 20/day)
✓ Collaboration with 3 team members
✓ Priority support
✓ All export formats
✓ API access

After 90 days, you can choose:
1. Continue with Professional ($39/mo or $372/year)
2. Switch to Author plan ($19/mo for 100 AI generations/day)
3. Use our generous Free plan (20 AI generations/day)

No action needed today - your account is already upgraded!

Questions? Reply to this email.

Thanks for being an early WriteCraft user,
[Your Name]
Founder, WriteCraft
```

---

## Phase 8: Testing & Launch (Week 11-12)
**Goal**: Comprehensive testing before public launch

### 8.1 Testing Checklist

**Functional Testing:**
- [ ] Free tier limits enforced correctly
- [ ] AI generation counting accurate
- [ ] Stripe checkout flow works
- [ ] Webhooks update subscriptions
- [ ] Trial period functions correctly
- [ ] Upgrade/downgrade flows work
- [ ] Usage dashboard displays correctly
- [ ] Feature gates block correctly
- [ ] Prompt caching reduces costs
- [ ] Model selection working

**User Experience Testing:**
- [ ] Pricing page renders correctly
- [ ] Upgrade prompts are clear and helpful
- [ ] Usage indicators update in real-time
- [ ] Billing portal accessible
- [ ] Email notifications sent
- [ ] Error messages are helpful

**Security Testing:**
- [ ] Users can't bypass tier limits
- [ ] Stripe webhooks verify signatures
- [ ] API keys secured properly
- [ ] Usage data isolated per user

### 8.2 Soft Launch Plan

**Week 1**: Beta test with 50 selected users
- Monitor usage patterns
- Collect feedback on pricing
- Fix any critical bugs

**Week 2**: Launch to 25% of users
- Email announcement
- Monitor conversion rates
- Adjust messaging if needed

**Week 3**: Full public launch
- Product Hunt launch
- Lifetime deal available
- Email all users
- Social media campaign

---

## Phase 9: Post-Launch Optimization (Week 13+)

### 9.1 Metrics to Track

**Daily Monitoring:**
- Active subscriptions by tier
- Trial-to-paid conversion rate
- AI cost per user by tier
- Feature adoption rates
- Churn rate

**Weekly Analysis:**
- Revenue by tier
- Gross margins
- Most used features
- Support ticket patterns
- Upgrade prompt conversion

### 9.2 A/B Testing Plan

**Test 1: Pricing**
- 50% see $39/mo Professional
- 50% see $29/mo Professional
- Measure: Revenue per user

**Test 2: Trial Length**
- 50% get 14-day trial
- 50% get 7-day trial
- Measure: Conversion rate

**Test 3: Upgrade Prompt Timing**
- Variant A: Show after 3 generations
- Variant B: Show after hitting limit
- Measure: Upgrade rate

---

## Implementation Priorities Summary

### Must-Have (Weeks 1-6)
1. Database schema with subscriptions
2. Subscription service layer
3. AI usage tracking
4. Stripe integration
5. Basic pricing page

### Should-Have (Weeks 7-10)
6. Feature gating enforcement
7. Prompt caching
8. Model selection
9. Usage dashboard
10. Upgrade prompts

### Nice-to-Have (Weeks 11-12)
11. Team management
12. Lifetime deals
13. Student discounts
14. Usage analytics dashboard
15. A/B testing infrastructure

---

## Cost Projections

### Development Costs
- Developer time (12 weeks @ $50/hr, 40hr/week): $24,000
- Stripe fees (2.9% + 30¢ per transaction): Variable
- Infrastructure scaling: $100-500/month

### Expected ROI
**Month 1**: 500 users
- 100 Author ($1,900/mo)
- 50 Professional ($1,950/mo)
- **MRR: $3,850**
- **Costs: ~$1,000**
- **Profit: $2,850**

**Month 6**: 2,000 users
- 800 Author ($15,200/mo)
- 400 Professional ($15,600/mo)
- 50 Team ($3,950/mo)
- **MRR: $34,750**
- **Costs: ~$8,000**
- **Profit: $26,750**

**Breakeven**: Month 2-3

---

## Risk Mitigation

### Technical Risks
- **Stripe integration fails**: Use Paddle as backup payment processor
- **AI costs spike**: Implement hard caps and alerts
- **Usage tracking inaccurate**: Add reconciliation jobs

### Business Risks
- **Low conversion**: Extend trial to 30 days, add more free features
- **High churn**: Improve onboarding, add sticky features
- **Competitor undercuts**: Focus on quality and integrations

---

## Success Criteria

**Technical:**
- ✓ 99.9% uptime for payment processing
- ✓ AI cost per user under tier pricing
- ✓ Usage tracking <1% error rate

**Business:**
- ✓ 10% trial-to-paid conversion
- ✓ <5% monthly churn
- ✓ 75%+ gross margins

**User:**
- ✓ >4.0 star rating
- ✓ <10% support tickets about pricing
- ✓ Positive sentiment on social media

---

## Next Steps

1. **Review this roadmap** with stakeholders
2. **Set up Stripe account** and create products
3. **Create database migration** for subscription tables
4. **Begin Phase 1 implementation**
5. **Schedule weekly progress reviews**

Remember: This is a marathon, not a sprint. Take time to test thoroughly and listen to user feedback. The goal is sustainable growth, not rushing to market.