diff --git a/client/src/components/ProjectOutline.tsx b/client/src/components/ProjectOutline.tsx
index bfafddc08836f8267bab9672874c3338e249ced2..c795e24c6d79bebe94399583141f9850fa770c45 100644
--- a/client/src/components/ProjectOutline.tsx
+++ b/client/src/components/ProjectOutline.tsx
@@ -9,50 +9,51 @@ import {
   FileText, 
   Folder, 
   FolderOpen,
   Plus,
   MoreHorizontal,
   Trash2,
   Edit2,
   GripVertical,
 } from 'lucide-react';
 import {
   DropdownMenu,
   DropdownMenuContent,
   DropdownMenuItem,
   DropdownMenuTrigger,
 } from '@/components/ui/dropdown-menu';
 import { cn } from '@/lib/utils';
 import type { ProjectSectionWithChildren } from '@shared/schema';
 import {
   DndContext,
   closestCenter,
   KeyboardSensor,
   PointerSensor,
   useSensor,
   useSensors,
   DragEndEvent,
+  DragOverEvent,
   DragOverlay,
   DragStartEvent,
   UniqueIdentifier,
 } from '@dnd-kit/core';
 import {
   SortableContext,
   sortableKeyboardCoordinates,
   useSortable,
   verticalListSortingStrategy,
 } from '@dnd-kit/sortable';
 import { CSS } from '@dnd-kit/utilities';
 
 interface ProjectOutlineProps {
   projectId: string;
   sections: ProjectSectionWithChildren[];
   activeSectionId: string | null;
   onSectionClick: (section: ProjectSectionWithChildren) => void;
   onClose?: () => void;
 }
 
 interface FlatSection {
   section: ProjectSectionWithChildren;
   depth: number;
   parentId: string | null;
 }
diff --git a/client/src/components/ProjectOutline.tsx b/client/src/components/ProjectOutline.tsx
index bfafddc08836f8267bab9672874c3338e249ced2..c795e24c6d79bebe94399583141f9850fa770c45 100644
--- a/client/src/components/ProjectOutline.tsx
+++ b/client/src/components/ProjectOutline.tsx
@@ -231,50 +232,51 @@ function SortableItem({
                 className="text-destructive"
                 data-testid={`button-delete-${section.id}`}
               >
                 <Trash2 className="h-4 w-4 mr-2" />
                 Delete
               </DropdownMenuItem>
             </DropdownMenuContent>
           </DropdownMenu>
         )}
       </div>
     </div>
   );
 }
 
 export function ProjectOutline({ 
   projectId, 
   sections, 
   activeSectionId, 
   onSectionClick,
   onClose
 }: ProjectOutlineProps) {
   const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());
   const [editingId, setEditingId] = useState<string | null>(null);
   const [editingTitle, setEditingTitle] = useState('');
   const [activeId, setActiveId] = useState<UniqueIdentifier | null>(null);
+  const [lastOverId, setLastOverId] = useState<UniqueIdentifier | null>(null);
   const queryClient = useQueryClient();
 
   const sensors = useSensors(
     useSensor(PointerSensor),
     useSensor(KeyboardSensor, {
       coordinateGetter: sortableKeyboardCoordinates,
     })
   );
 
   const createMutation = useMutation({
     mutationFn: async (data: { parentId: string | null; title: string; type: 'folder' | 'page'; position: number }) => {
       const response = await apiRequest('POST', `/api/projects/${projectId}/sections`, data);
       return response.json();
     },
     onSuccess: (newSection, variables) => {
       queryClient.invalidateQueries({ queryKey: ['/api/projects', projectId, 'sections'] });
       
       // If a page was created inside a folder, expand that folder and select the new page
       if (variables.parentId) {
         setExpandedIds(prev => {
           const next = new Set(prev);
           next.add(variables.parentId!);
           return next;
         });
       }
diff --git a/client/src/components/ProjectOutline.tsx b/client/src/components/ProjectOutline.tsx
index bfafddc08836f8267bab9672874c3338e249ced2..c795e24c6d79bebe94399583141f9850fa770c45 100644
--- a/client/src/components/ProjectOutline.tsx
+++ b/client/src/components/ProjectOutline.tsx
@@ -349,64 +351,82 @@ export function ProjectOutline({
     setEditingId(section.id);
     setEditingTitle(section.title);
   };
 
   const handleSaveEdit = () => {
     if (editingId && editingTitle.trim()) {
       updateMutation.mutate({ id: editingId, title: editingTitle.trim() });
     } else {
       setEditingId(null);
     }
   };
 
   const handleCancelEdit = () => {
     setEditingId(null);
     setEditingTitle('');
   };
 
   const handleDelete = (id: string) => {
     if (confirm('Delete this item and all its contents? This cannot be undone.')) {
       deleteMutation.mutate(id);
     }
   };
 
   const handleDragStart = (event: DragStartEvent) => {
     setActiveId(event.active.id);
+    setLastOverId(null);
+  };
+
+  const handleDragOver = (event: DragOverEvent) => {
+    const { active, over } = event;
+
+    if (!over || over.id === active.id) {
+      return;
+    }
+
+    setLastOverId(over.id);
   };
 
   const handleDragEnd = (event: DragEndEvent) => {
     const { active, over } = event;
     setActiveId(null);
+    setLastOverId(null);
 
-    if (!over || active.id === over.id) {
-      return;
+    let overId: UniqueIdentifier | null = over?.id ?? null;
+
+    if (!overId || overId === active.id) {
+      if (lastOverId && lastOverId !== active.id) {
+        overId = lastOverId;
+      } else {
+        return;
+      }
     }
 
     // Find source and target in the full tree
     const flatList = flattenTree(sections);
     const sourceItem = flatList.find(f => f.section.id === active.id);
-    const targetItem = flatList.find(f => f.section.id === over.id);
+    const targetItem = flatList.find(f => f.section.id === overId);
 
     if (!sourceItem || !targetItem) {
       return;
     }
 
     console.log('[DND] Drag ended:', {
       source: { id: sourceItem.section.id, title: sourceItem.section.title, parentId: sourceItem.parentId },
       target: { id: targetItem.section.id, title: targetItem.section.title, type: targetItem.section.type, parentId: targetItem.parentId }
     });
 
     // Determine new parent and position
     let newParentId: string | null;
     
     // If dropping onto a folder, make it the first child of that folder
     if (targetItem.section.type === 'folder') {
       newParentId = targetItem.section.id;
       console.log('[DND] Dropping into folder:', targetItem.section.title);
       // Auto-expand the folder
       setExpandedIds(prev => new Set(prev).add(targetItem.section.id));
     } else {
       // If dropping onto a page, use the same parent as the target
       newParentId = targetItem.parentId;
       console.log('[DND] Dropping next to page, using parent:', newParentId);
     }
 
diff --git a/client/src/components/ProjectOutline.tsx b/client/src/components/ProjectOutline.tsx
index bfafddc08836f8267bab9672874c3338e249ced2..c795e24c6d79bebe94399583141f9850fa770c45 100644
--- a/client/src/components/ProjectOutline.tsx
+++ b/client/src/components/ProjectOutline.tsx
@@ -549,50 +569,51 @@ export function ProjectOutline({
             <DropdownMenuTrigger asChild>
               <Button size="sm" variant="ghost" className="h-7 w-7 p-0" data-testid="button-add-section">
                 <Plus className="h-4 w-4" />
               </Button>
             </DropdownMenuTrigger>
             <DropdownMenuContent align="end">
               <DropdownMenuItem onClick={() => handleCreateFolder(null)} data-testid="button-create-folder">
                 <Folder className="h-4 w-4 mr-2" />
                 New Folder
               </DropdownMenuItem>
               <DropdownMenuItem onClick={() => handleCreatePage(null)} data-testid="button-create-page">
                 <FileText className="h-4 w-4 mr-2" />
                 New Page
               </DropdownMenuItem>
             </DropdownMenuContent>
           </DropdownMenu>
         </div>
       </div>
 
       {/* Tree with drag and drop */}
       <div className="flex-1 overflow-y-auto p-2">
         <DndContext
           sensors={sensors}
           collisionDetection={closestCenter}
           onDragStart={handleDragStart}
+          onDragOver={handleDragOver}
           onDragEnd={handleDragEnd}
         >
           <SortableContext
             items={visibleSections.map(f => f.section.id)}
             strategy={verticalListSortingStrategy}
           >
             {visibleSections.map((flatSection) => (
               <SortableItem
                 key={flatSection.section.id}
                 flatSection={flatSection}
                 isActive={flatSection.section.id === activeSectionId}
                 isExpanded={expandedIds.has(flatSection.section.id)}
                 isEditing={editingId === flatSection.section.id}
                 editingTitle={editingTitle}
                 onToggleExpanded={() => toggleExpanded(flatSection.section.id)}
                 onSectionClick={() => onSectionClick(flatSection.section)}
                 onStartEdit={() => handleStartEdit(flatSection.section)}
                 onSaveEdit={handleSaveEdit}
                 onCancelEdit={handleCancelEdit}
                 onTitleChange={setEditingTitle}
                 onCreateFolder={() => handleCreateFolder(flatSection.section.id)}
                 onCreatePage={() => handleCreatePage(flatSection.section.id)}
                 onDelete={() => handleDelete(flatSection.section.id)}
               />
             ))}
