diff --git a/client/src/components/ProjectOutline.tsx b/client/src/components/ProjectOutline.tsx
index f72b9cd80850c25230e241988b922409c2ea0a6e..d65205ff0da6f3ebb7b3719a08fa199d445f4aed 100644
--- a/client/src/components/ProjectOutline.tsx
+++ b/client/src/components/ProjectOutline.tsx
@@ -417,92 +417,101 @@ export function ProjectOutline({
 
     let overId: UniqueIdentifier | null = over?.id ?? null;
 
     if (!overId || overId === active.id) {
       if (lastOverId && lastOverId !== active.id) {
         overId = lastOverId;
       } else {
         return;
       }
     }
 
     // Find source and target in the full tree
     const flatList = flattenTree(sections);
     const sourceItem = flatList.find(f => f.section.id === active.id);
     const targetItem = flatList.find(f => f.section.id === overId);
 
     if (!sourceItem || !targetItem) {
       return;
     }
 
     console.log('[DND] Drag ended:', {
       source: { id: sourceItem.section.id, title: sourceItem.section.title, parentId: sourceItem.parentId },
       target: { id: targetItem.section.id, title: targetItem.section.title, type: targetItem.section.type, parentId: targetItem.parentId }
     });
 
-    // Determine new parent and position
+    // Determine new parent and desired ordering
     let newParentId: string | null;
-    
-    // If dropping onto a folder, make it the first child of that folder
+
+    // If dropping onto a folder, make it a child of that folder
     if (targetItem.section.type === 'folder') {
       newParentId = targetItem.section.id;
       console.log('[DND] Dropping into folder:', targetItem.section.title);
       // Auto-expand the folder
       setExpandedIds(prev => new Set(prev).add(targetItem.section.id));
     } else {
       // If dropping onto a page, use the same parent as the target
       newParentId = targetItem.parentId;
       console.log('[DND] Dropping next to page, using parent:', newParentId);
     }
 
     // Check if this is truly a no-op
     if (sourceItem.parentId === newParentId) {
       console.log('[DND] No change needed - already in the same parent');
       return;
     }
 
-    // Build the reorder payload - just move the item to the beginning of its new parent
-    const reorders: Array<{ id: string; parentId: string | null; position: number }> = [];
-    
-    // Get all current children of the target parent
-    const targetChildren = flatList.filter(f => f.parentId === newParentId && f.section.id !== sourceItem.section.id);
-    
-    // Add the moved item as the first child
-    reorders.push({
-      id: sourceItem.section.id,
+    // Build the reorder payload keeping the relative ordering of the target parent's children
+    const siblings = flatList.filter(
+      f => f.parentId === newParentId && f.section.id !== sourceItem.section.id
+    );
+
+    let orderedIds: string[] = [];
+
+    if (targetItem.section.type === 'folder') {
+      // When dropping directly on a folder, append the moved item to the end of that folder
+      orderedIds = [...siblings.map(item => item.section.id), sourceItem.section.id];
+    } else {
+      // When dropping on a page, insert before the target page (matching the visual cue)
+      const targetIndex = siblings.findIndex(item => item.section.id === targetItem.section.id);
+
+      if (targetIndex === -1) {
+        orderedIds = [...siblings.map(item => item.section.id), sourceItem.section.id];
+      } else {
+        orderedIds = [
+          ...siblings.slice(0, targetIndex).map(item => item.section.id),
+          sourceItem.section.id,
+          ...siblings.slice(targetIndex).map(item => item.section.id),
+        ];
+      }
+    }
+
+    const reorders: Array<{ id: string; parentId: string | null; position: number }> = orderedIds.map((id, index) => ({
+      id,
       parentId: newParentId,
-      position: 0,
-    });
-    
-    // Reposition existing children
-    targetChildren.forEach((item, index) => {
-      reorders.push({
-        id: item.section.id,
-        parentId: newParentId,
-        position: index + 1,
-      });
-    });
+      position: index,
+    }));
 
     console.log('[DND] Reorder payload:', reorders);
     reorderMutation.mutate(reorders);
   };
 
   // Filter sections based on expanded state for rendering
   const getVisibleSections = (sectionList: ProjectSectionWithChildren[], depth = 0, parentId: string | null = null): FlatSection[] => {
     const result: FlatSection[] = [];
     
     for (const section of sectionList) {
       result.push({ section, depth, parentId });
       
       if (section.type === 'folder' && expandedIds.has(section.id) && section.children && section.children.length > 0) {
         result.push(...getVisibleSections(section.children, depth + 1, section.id));
       }
     }
     
     return result;
   };
 
   const visibleSections = getVisibleSections(sections);
   const activeDragSection = visibleSections.find(f => f.section.id === activeId);
 
   // Empty state
   if (!sections || sections.length === 0) {
