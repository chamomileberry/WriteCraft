import { useState, useEffect, useCallback, useRef, forwardRef, useImperativeHandle } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import { Extension } from '@tiptap/core';
import { NodeSelection } from '@tiptap/pm/state';
import StarterKit from '@tiptap/starter-kit';
import Link from '@tiptap/extension-link';
import Mention from '@tiptap/extension-mention';
import { suggestion } from '@/lib/suggestion';
import CharacterCount from '@tiptap/extension-character-count';
import { TextAlign } from '@tiptap/extension-text-align';
import { TextStyle } from '@tiptap/extension-text-style';
import { Color } from '@tiptap/extension-color';
import { Highlight } from '@tiptap/extension-highlight';
import { FontFamily } from '@tiptap/extension-font-family';
import { BulletList } from '@tiptap/extension-bullet-list';
import { OrderedList } from '@tiptap/extension-ordered-list';
import { ListItem } from '@tiptap/extension-list-item';
import Image from '@tiptap/extension-image';
import { Table as TiptapTable } from '@tiptap/extension-table';
import TableRow from '@tiptap/extension-table-row';
import TableCell from '@tiptap/extension-table-cell';
import TableHeader from '@tiptap/extension-table-header';
import CodeBlockLowlight from '@tiptap/extension-code-block-lowlight';
import HorizontalRule from '@tiptap/extension-horizontal-rule';
import Youtube from '@tiptap/extension-youtube';
import Focus from '@tiptap/extension-focus';
import Typography from '@tiptap/extension-typography';
import { createLowlight } from 'lowlight';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { 
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { 
  ImageIcon,
  Video,
  LinkIcon,
  Download,
} from 'lucide-react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiRequest } from '@/lib/queryClient';
import { useToast } from '@/hooks/use-toast';
import { useWorkspaceStore, EditorActions } from '@/stores/workspaceStore';
import { EditorToolbar } from '@/components/ui/editor-toolbar';
import type { ProjectSection } from '@/types/project';

// Custom HorizontalRule extension
const CustomHorizontalRule = HorizontalRule.extend({
  addKeyboardShortcuts() {
    return {
      'Backspace': () => {
        const { state, dispatch } = this.editor.view;
        const { selection } = state;
        
        if (selection instanceof NodeSelection && selection.node.type.name === 'horizontalRule') {
          const tr = state.tr.deleteSelection();
          dispatch(tr);
          return true;
        }
        
        if (selection.empty && selection.$from.pos > 0) {
          const $pos = selection.$from;
          const before = $pos.nodeBefore;
          if (before && before.type.name === 'horizontalRule') {
            const hrPos = $pos.pos - before.nodeSize;
            const tr = state.tr.delete(hrPos, $pos.pos);
            dispatch(tr);
            return true;
          }
        }
        
        return false;
      },
      'Delete': () => {
        const { state, dispatch } = this.editor.view;
        const { selection } = state;
        const { $from } = selection;
        
        if ($from.pos < state.doc.content.size) {
          const nodeAtPos = state.doc.nodeAt($from.pos);
          if (nodeAtPos?.type.name === 'horizontalRule') {
            const tr = state.tr.delete($from.pos, $from.pos + nodeAtPos.nodeSize);
            dispatch(tr);
            return true;
          }
        }
        
        if (selection instanceof NodeSelection && selection.node.type.name === 'horizontalRule') {
          const tr = state.tr.deleteSelection();
          dispatch(tr);
          return true;
        }
        
        return false;
      }
    };
  }
});

// Custom FontSize extension
declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    fontSize: {
      setFontSize: (size: string) => ReturnType
      unsetFontSize: () => ReturnType
    }
  }
}

const FontSize = Extension.create({
  name: 'fontSize',
  addOptions() {
    return {
      types: ['textStyle'],
    }
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseHTML: element => element.style.fontSize.replace(/['"+]/g, ''),
            renderHTML: attributes => {
              if (!attributes.fontSize) {
                return {}
              }
              return {
                style: `font-size: ${attributes.fontSize}`,
              }
            },
          },
        },
      },
    ]
  },
  addCommands() {
    return {
      setFontSize: fontSize => ({ chain }) => {
        return chain()
          .setMark('textStyle', { fontSize: fontSize })
          .run()
      },
      unsetFontSize: () => ({ chain }) => {
        return chain()
          .setMark('textStyle', { fontSize: null })
          .removeEmptyTextStyle()
          .run()
      },
    }
  },
});

interface SectionEditorProps {
  projectId: string;
  section: ProjectSection;
  onContentChange: (hasChanges: boolean) => void;
  onSaveStatusChange: (status: 'saved' | 'saving' | 'unsaved') => void;
  onLastSaveTimeChange: (time: Date) => void;
  onWordCountChange: (count: number) => void;
}

export const SectionEditor = forwardRef<{ saveContent: () => Promise<void> }, SectionEditorProps>(
  ({ projectId, section, onContentChange, onSaveStatusChange, onLastSaveTimeChange, onWordCountChange }, ref) => {
    const [isInsertImageDialogOpen, setIsInsertImageDialogOpen] = useState(false);
    const [isInsertVideoDialogOpen, setIsInsertVideoDialogOpen] = useState(false);
    const [isInsertLinkDialogOpen, setIsInsertLinkDialogOpen] = useState(false);
    const [insertImageUrl, setInsertImageUrl] = useState('');
    const [insertVideoUrl, setInsertVideoUrl] = useState('');
    const [insertLinkUrl, setInsertLinkUrl] = useState('');
    
    const { toast } = useToast();
    const queryClient = useQueryClient();
    const autosaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const { updateEditorContext, clearEditorContext, registerEditorActions } = useWorkspaceStore();

    const lowlight = createLowlight();

    // Save mutation
    const saveMutation = useMutation({
      mutationFn: async (content: string) => {
        const response = await apiRequest('PUT', `/api/projects/${projectId}/sections/${section.id}`, { 
          content 
        });
        return response.json();
      },
      onSuccess: () => {
        onSaveStatusChange('saved');
        onLastSaveTimeChange(new Date());
        onContentChange(false);
        queryClient.invalidateQueries({ queryKey: ['/api/projects', projectId, 'sections', section.id] });
      },
      onError: (error: any) => {
        onSaveStatusChange('unsaved');
        toast({
          title: "Save failed",
          description: error.message || "Failed to save section. Please try again.",
          variant: "destructive"
        });
      },
    });

    // Initialize TipTap editor
    const editor = useEditor({
      extensions: [
        StarterKit.configure({
          bulletList: false,
          orderedList: false,
          listItem: false,
          link: false,
          codeBlock: false,
          horizontalRule: false,
        }),
        CharacterCount,
        TextStyle,
        FontSize,
        TextAlign.configure({
          types: ['heading', 'paragraph'],
        }),
        Color.configure({
          types: ['textStyle'],
        }),
        Highlight.configure({
          multicolor: true,
        }),
        FontFamily.configure({
          types: ['textStyle'],
        }),
        BulletList,
        OrderedList,
        ListItem,
        Link.configure({
          openOnClick: false,
        }),
        Mention.configure({
          suggestion,
        }),
        Image,
        TiptapTable.configure({
          resizable: true,
        }),
        TableRow,
        TableHeader,
        TableCell,
        CodeBlockLowlight.configure({
          lowlight,
        }),
        CustomHorizontalRule,
        Youtube.configure({
          controls: false,
          nocookie: true,
        }),
        Focus.configure({
          className: 'has-focus',
          mode: 'all',
        }),
        Typography,
      ],
      content: section?.content || '',
      editorProps: {
        attributes: {
          class: 'prose dark:prose-invert mx-auto focus:outline-none min-h-[500px] p-4',
        },
      },
      onUpdate: ({ editor }) => {
        onSaveStatusChange('unsaved');
        onContentChange(true);
        
        // Update word count
        const words = editor.storage.characterCount?.words() || 0;
        onWordCountChange(words);
        
        // Update editor context for AI
        updateEditorContext({
          content: editor.getText(),
          htmlContent: editor.getHTML(),
          title: section.title,
          type: 'section',
          entityId: section.id
        });
        
        // Auto-save after 2 seconds
        if (autosaveTimeoutRef.current) {
          clearTimeout(autosaveTimeoutRef.current);
        }
        
        autosaveTimeoutRef.current = setTimeout(() => {
          saveContent();
        }, 2000);
      },
    });

    // Update editor content when section changes
    useEffect(() => {
      if (editor && section) {
        editor.commands.setContent(section.content || '');
        
        // Update word count immediately
        const words = editor.storage.characterCount?.words() || 0;
        onWordCountChange(words);
      }
    }, [section?.id, editor]);

    // Register editor actions
    useEffect(() => {
      if (editor) {
        const editorActions: EditorActions = {
          insertContent: (content: string) => {
            editor.chain().focus().insertContent(content).run();
          },
          replaceContent: (content: string) => {
            editor.commands.setContent(content);
          },
          replaceSelection: (content: string) => {
            editor.chain().focus().deleteSelection().insertContent(content).run();
          },
          selectAll: () => {
            editor.commands.selectAll();
          },
          insertAtCursor: (content: string) => {
            editor.chain().focus().insertContent(content).run();
          }
        };
        
        registerEditorActions(editorActions);
      }
    }, [editor, registerEditorActions]);

    // Clear context on unmount
    useEffect(() => {
      return () => {
        clearEditorContext();
      };
    }, [clearEditorContext]);

    // Save content function
    const saveContent = useCallback(async () => {
      if (editor) {
        onSaveStatusChange('saving');
        const content = editor.getHTML();
        await saveMutation.mutateAsync(content);
      }
    }, [editor, saveMutation, onSaveStatusChange]);

    // Expose save via ref
    useImperativeHandle(ref, () => ({
      saveContent,
    }));

    // Media insertion handlers
    const handleInsertImage = () => {
      if (insertImageUrl.trim()) {
        editor?.chain().focus().setImage({ src: insertImageUrl.trim() }).run();
        setInsertImageUrl('');
        setIsInsertImageDialogOpen(false);
      }
    };

    const handleInsertVideo = () => {
      if (insertVideoUrl.trim()) {
        editor?.commands.setYoutubeVideo({
          src: insertVideoUrl.trim(),
          width: 640,
          height: 480,
        });
        setInsertVideoUrl('');
        setIsInsertVideoDialogOpen(false);
      }
    };

    const handleInsertLink = () => {
      if (insertLinkUrl.trim()) {
        editor?.chain().focus().setLink({ href: insertLinkUrl.trim() }).run();
        setInsertLinkUrl('');
        setIsInsertLinkDialogOpen(false);
      }
    };

    // Export functionality
    const handleExport = (format: string) => {
      const content = editor?.getHTML() || '';
      const title = section?.title || 'Untitled';
      
      switch(format) {
        case 'html':
          const htmlFile = new Blob([content], { type: 'text/html' });
          const htmlLink = document.createElement('a');
          htmlLink.href = URL.createObjectURL(htmlFile);
          htmlLink.download = `${title}.html`;
          htmlLink.click();
          break;
          
        case 'pdf':
          toast({
            title: "PDF Export",
            description: "Opening print dialog. Select 'Save as PDF' from the destination dropdown.",
          });
          setTimeout(() => window.print(), 500);
          break;
          
        case 'docx':
          const textContent = editor?.getText() || '';
          const docxBlob = new Blob([`${title}\n\n${textContent}`], { 
            type: 'text/plain' 
          });
          const docxLink = document.createElement('a');
          docxLink.href = URL.createObjectURL(docxBlob);
          docxLink.download = `${title}.txt`;
          docxLink.click();
          break;
      }
    };

    if (!editor) {
      return null;
    }

    return (
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Toolbar */}
        <div className="border-b bg-background/95 backdrop-blur">
          <div className="flex items-center justify-between gap-2 p-4">
            <div className="flex-1">
              <EditorToolbar editor={editor} title={section.title} />
            </div>
            
            {/* Media buttons */}
            <div className="flex items-center gap-2">
              <Dialog open={isInsertImageDialogOpen} onOpenChange={setIsInsertImageDialogOpen}>
                <DialogTrigger asChild>
                  <Button variant="outline" size="sm">
                    <ImageIcon className="h-4 w-4" />
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Insert Image</DialogTitle>
                    <DialogDescription>
                      Enter the URL of the image you want to insert.
                    </DialogDescription>
                  </DialogHeader>
                  <Input
                    value={insertImageUrl}
                    onChange={(e) => setInsertImageUrl(e.target.value)}
                    placeholder="https://example.com/image.jpg"
                    onKeyDown={(e) => e.key === 'Enter' && handleInsertImage()}
                  />
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setIsInsertImageDialogOpen(false)}>
                      Cancel
                    </Button>
                    <Button onClick={handleInsertImage} disabled={!insertImageUrl.trim()}>
                      Insert
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>

              <Dialog open={isInsertVideoDialogOpen} onOpenChange={setIsInsertVideoDialogOpen}>
                <DialogTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Video className="h-4 w-4" />
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Insert Video</DialogTitle>
                    <DialogDescription>
                      Enter the YouTube URL of the video you want to insert.
                    </DialogDescription>
                  </DialogHeader>
                  <Input
                    value={insertVideoUrl}
                    onChange={(e) => setInsertVideoUrl(e.target.value)}
                    placeholder="https://www.youtube.com/watch?v=..."
                    onKeyDown={(e) => e.key === 'Enter' && handleInsertVideo()}
                  />
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setIsInsertVideoDialogOpen(false)}>
                      Cancel
                    </Button>
                    <Button onClick={handleInsertVideo} disabled={!insertVideoUrl.trim()}>
                      Insert
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>

              <Dialog open={isInsertLinkDialogOpen} onOpenChange={setIsInsertLinkDialogOpen}>
                <DialogTrigger asChild>
                  <Button variant="outline" size="sm">
                    <LinkIcon className="h-4 w-4" />
                  </Button>
                </DialogTrigger>
                <DialogContent>
                  <DialogHeader>
                    <DialogTitle>Insert Link</DialogTitle>
                    <DialogDescription>
                      Enter the URL you want to link to.
                    </DialogDescription>
                  </DialogHeader>
                  <Input
                    value={insertLinkUrl}
                    onChange={(e) => setInsertLinkUrl(e.target.value)}
                    placeholder="https://example.com"
                    onKeyDown={(e) => e.key === 'Enter' && handleInsertLink()}
                  />
                  <DialogFooter>
                    <Button variant="outline" onClick={() => setIsInsertLinkDialogOpen(false)}>
                      Cancel
                    </Button>
                    <Button onClick={handleInsertLink} disabled={!insertLinkUrl.trim()}>
                      Insert
                    </Button>
                  </DialogFooter>
                </DialogContent>
              </Dialog>

              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Download className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent>
                  <DropdownMenuItem onClick={() => handleExport('html')}>
                    Export as HTML
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => handleExport('pdf')}>
                    Export as PDF
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => handleExport('docx')}>
                    Export as DOCX
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </div>

        {/* Editor */}
        <div className="flex-1 overflow-auto">
          <EditorContent editor={editor} />
        </div>
      </div>
    );
  }
);

SectionEditor.displayName = 'SectionEditor';