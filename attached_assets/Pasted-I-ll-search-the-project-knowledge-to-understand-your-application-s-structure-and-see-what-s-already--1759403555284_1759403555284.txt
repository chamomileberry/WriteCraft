I’ll search the project knowledge to understand your application’s structure and see what’s already in place for handling images.​​​​​​​​​​​​​​​​

Based on your project knowledge, I can see you have a world-building application with multiple content types that use a hybrid approach: structured data forms that can be converted to rich HTML articles. Currently, images are only inserted via URL. Here’s a strategic implementation plan for a photo upload system:

## Strategic Implementation Plan

### 1. **Database Schema Updates**

Add image fields to all content type tables in `shared/schema.ts`:

```typescript
// Add to each content type table (characters, locations, weapons, etc.)
imageUrl: text("image_url"),
imageThumbnail: text("image_thumbnail"), // Optional: for performance
imageCaption: text("image_caption"),
imageAlt: text("image_alt"), // For accessibility
```

### 2. **Backend File Upload Infrastructure**

Create a new file upload service (`server/upload-service.ts`):

```typescript
import multer from 'multer';
import path from 'path';
import { nanoid } from 'nanoid';
import fs from 'fs/promises';

// Configure storage (you can switch to S3/Cloudinary later)
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads', 'images');
    await fs.mkdir(uploadDir, { recursive: true });
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueName = `${nanoid()}-${Date.now()}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  }
});

const fileFilter = (req: any, file: any, cb: any) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, GIF, and WebP allowed.'), false);
  }
};

export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  }
});
```

Add upload route (`server/routes/upload.routes.ts`):

```typescript
import { Router } from 'express';
import { upload } from '../upload-service';

const router = Router();

router.post('/image', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const imageUrl = `/uploads/images/${req.file.filename}`;
    
    res.json({
      imageUrl,
      filename: req.file.filename,
      size: req.file.size,
      mimetype: req.file.mimetype
    });
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ error: 'Upload failed' });
  }
});

export default router;
```

Serve static files in `server/index.ts`:

```typescript
import express from 'express';
import path from 'path';

app.use('/uploads', express.static(path.join(process.cwd(), 'uploads')));
```

### 3. **Reusable Image Upload Component**

Create `client/src/components/ImageUpload.tsx`:

```typescript
import { useState, useRef } from 'react';
import { Button } from './ui/button';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Upload, X, ImageIcon } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface ImageUploadProps {
  value?: string;
  onChange: (imageUrl: string) => void;
  onCaptionChange?: (caption: string) => void;
  caption?: string;
  label?: string;
}

export function ImageUpload({ 
  value, 
  onChange, 
  onCaptionChange, 
  caption = '', 
  label = 'Image' 
}: ImageUploadProps) {
  const [uploading, setUploading] = useState(false);
  const [imageUrl, setImageUrl] = useState(value || '');
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file size
    if (file.size > 5 * 1024 * 1024) {
      toast({
        title: 'File too large',
        description: 'Image must be less than 5MB',
        variant: 'destructive'
      });
      return;
    }

    setUploading(true);
    try {
      const formData = new FormData();
      formData.append('image', file);

      const response = await fetch('/api/upload/image', {
        method: 'POST',
        body: formData,
        credentials: 'include'
      });

      if (!response.ok) throw new Error('Upload failed');

      const data = await response.json();
      setImageUrl(data.imageUrl);
      onChange(data.imageUrl);

      toast({
        title: 'Upload successful',
        description: 'Your image has been uploaded'
      });
    } catch (error) {
      console.error('Upload error:', error);
      toast({
        title: 'Upload failed',
        description: 'Failed to upload image',
        variant: 'destructive'
      });
    } finally {
      setUploading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleRemove = () => {
    setImageUrl('');
    onChange('');
  };

  return (
    <div className="space-y-4">
      <Label>{label}</Label>
      
      {imageUrl ? (
        <div className="relative inline-block">
          <img 
            src={imageUrl} 
            alt="Uploaded" 
            className="max-w-full h-auto max-h-64 rounded-lg border"
          />
          <Button
            variant="destructive"
            size="icon"
            className="absolute top-2 right-2"
            onClick={handleRemove}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      ) : (
        <div className="border-2 border-dashed rounded-lg p-6 text-center">
          <ImageIcon className="mx-auto h-12 w-12 text-muted-foreground mb-2" />
          <p className="text-sm text-muted-foreground mb-4">
            Upload an image or enter a URL
          </p>
          <Button
            type="button"
            variant="outline"
            onClick={() => fileInputRef.current?.click()}
            disabled={uploading}
          >
            <Upload className="mr-2 h-4 w-4" />
            {uploading ? 'Uploading...' : 'Choose File'}
          </Button>
          <input
            ref={fileInputRef}
            type="file"
            accept="image/jpeg,image/png,image/gif,image/webp"
            onChange={handleFileChange}
            className="hidden"
          />
        </div>
      )}

      {/* Alternative: URL input */}
      <div className="space-y-2">
        <Label htmlFor="image-url">Or enter image URL</Label>
        <Input
          id="image-url"
          value={imageUrl}
          onChange={(e) => {
            setImageUrl(e.target.value);
            onChange(e.target.value);
          }}
          placeholder="https://example.com/image.jpg"
        />
      </div>

      {/* Caption field */}
      {onCaptionChange && (
        <div className="space-y-2">
          <Label htmlFor="image-caption">Caption (optional)</Label>
          <Input
            id="image-caption"
            value={caption}
            onChange={(e) => onCaptionChange(e.target.value)}
            placeholder="Add a caption for this image"
          />
        </div>
      )}
    </div>
  );
}
```

### 4. **Integrate with Content Type Forms**

Update your content type form configs (e.g., in `client/src/components/forms/content-types/`):

```typescript
// Example: characterConfig.ts
export const characterConfig = {
  fields: [
    // ... existing fields ...
    {
      name: 'imageUrl',
      label: 'Character Portrait',
      type: 'custom',
      component: ImageUpload,
      section: 'Basic Information'
    }
  ]
};
```

Or add it directly to your form components:

```tsx
// In your ContentEditor or specific form component
import { ImageUpload } from '@/components/ImageUpload';

<ImageUpload
  value={formData.imageUrl}
  onChange={(url) => setFormData({ ...formData, imageUrl: url })}
  onCaptionChange={(caption) => setFormData({ ...formData, imageCaption: caption })}
  caption={formData.imageCaption}
  label="Upload Image"
/>
```

### 5. **Update Article Generation**

Modify `server/article-generation.ts` to include images:

```typescript
// Add this helper function
function createImageSection(imageUrl?: string, caption?: string, alt?: string): string {
  if (!imageUrl) return '';
  
  const altText = escapeHtml(alt || caption || 'Image');
  const captionHtml = caption 
    ? `<figcaption>${escapeHtml(caption)}</figcaption>` 
    : '';
  
  return `
    <figure style="margin: 2em 0; text-align: center;">
      <img src="${escapeHtml(imageUrl)}" alt="${altText}" style="max-width: 100%; height: auto; border-radius: 8px;" />
      ${captionHtml}
    </figure>
  `;
}

// Update each generator function
function generateCharacterArticle(character: Character): string {
  const sections: string[] = [];
  
  // Header with name
  if (character.givenName || character.familyName) {
    const fullName = [character.givenName, character.familyName]
      .filter(Boolean)
      .map(escapeHtml)
      .join(' ');
    sections.push(`<h1>${fullName}</h1>`);
  }
  
  // ADD IMAGE RIGHT AFTER HEADER
  if (character.imageUrl) {
    sections.push(createImageSection(
      character.imageUrl, 
      character.imageCaption,
      character.imageAlt || `Portrait of ${character.givenName || 'character'}`
    ));
  }
  
  // ... rest of the article generation
}
```

### 6. **Display Images in Article Editor**

The TipTap editor (used in `ArticleEditor`) already supports images. Ensure the Image extension is configured:

```typescript
// In ArticleEditor.tsx
import Image from '@tiptap/extension-image';

const editor = useEditor({
  extensions: [
    // ... other extensions
    Image.configure({
      inline: true,
      allowBase64: true,
      HTMLAttributes: {
        class: 'max-w-full h-auto rounded-lg',
      },
    }),
  ],
  // ... rest of config
});
```

### 7. **Update Schema Validation**

Update insert schemas in `shared/schema.ts`:

```typescript
export const insertCharacterSchema = createInsertSchema(characters, {
  // ... existing validations
  imageUrl: z.string().url().optional().or(z.literal('')),
  imageCaption: z.string().optional(),
  imageAlt: z.string().optional(),
});
```

## Migration Path

1. **Phase 1**: Add database columns (create migration)
1. **Phase 2**: Implement upload service and routes
1. **Phase 3**: Create reusable ImageUpload component
1. **Phase 4**: Add to one content type (e.g., characters) for testing
1. **Phase 5**: Roll out to all content types
1. **Phase 6**: Update article generation for all types
1. **Phase 7**: (Optional) Migrate to cloud storage (Cloudinary/S3)

## Cloud Storage Alternative

For production, consider using Cloudinary:

```typescript
// server/upload-service.ts with Cloudinary
import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function uploadToCloudinary(file: Express.Multer.File) {
  const result = await cloudinary.uploader.upload(file.path, {
    folder: 'worldbuilding',
    resource_type: 'image',
    transformation: [
      { width: 1200, height: 1200, crop: 'limit' },
      { quality: 'auto', fetch_format: 'auto' }
    ]
  });
  
  return {
    imageUrl: result.secure_url,
    thumbnailUrl: result.eager?.[0]?.secure_url,
  };
}
```

This approach gives you:

- ✅ Reusable component across all content types
- ✅ Proper database storage
- ✅ Automatic image display in generated articles
- ✅ Rich editor integration
- ✅ Scalable to cloud storage
- ✅ Fallback to URL input for flexibility

Would you like me to create any of these files as complete working examples, or help you implement a specific part first?​​​​​​​​​​​​​​​​